
<!-- saved from url=(0048)http://211.228.163.31/30stair/eu/eu.php?pname=eu -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-949">
      <title>유클리드 호제법</title>
      
      <link rel="stylesheet" type="text/css" href="./유클리드 호제법_files/main.css">

	  <link href="./유클리드 호제법_files/shCore.css" rel="stylesheet" type="text/css"> 
	  <link href="./유클리드 호제법_files/shThemeDefault.css" rel="stylesheet" type="text/css"> 
	  <script src="./유클리드 호제법_files/shCore.js" type="text/javascript"></script> 
	  <script src="./유클리드 호제법_files/shBrushCpp.js" type="text/javascript"></script>

	  <script language="javascript"> 
	    SyntaxHighlighter.config.bloggerMode = true;
	    SyntaxHighlighter.config.clipboardSwf = '/scripts/clipboard.swf';
	    SyntaxHighlighter.all();
	  </script> 

   </head>
   <body>


   <h3>1.유클리드 호제법</h3>

<p> A 를 B 로 나눈 몫을 q , 나머지를 r 이라하면 , ( 20 을 8 로 나눈 몫은 2 나머지는 4)

</p><blockquote>
<img src="./유클리드 호제법_files/eu1.gif">
<br><img src="./유클리드 호제법_files/eu2.gif">
</blockquote>

<p>A , B 의 최대 공약수는  , B , r 의 최대 공약수와 같다. (20 과 8 의 최대공약수는 8 과 4 의 최대 공약수와 같다.)

</p><h3>(1) 직관적으로 이해하기 </h3>

마음 속으로 임의의 수 하나를  생각합니다.

<ol>
<li>저는 20 을 생각했습니다.
</li><li>20 을 두 수의 합으로 표시해 봅니다.

<p>20 = 8 + 12 

</p><p>이렇게 하는 순간 20, 8의 공약수와 8,12 의 공약수는 같습니다. 이것이 유클리드 알고리즘의 전부입니다.

</p><pre>20 , 8 의 공약수 : 1 , 2 , 4 
8 , 12 의 공약수 : 1 , 2 , 4
</pre>

<p>우연히 같은 공약수가 나온것 이 아닐까요?

</p><p>그러면 20 을 6 + 14 로 나타내면 

</p><p>20 = 6 + 14

</p><pre>20 과 6 의 공약수 : 1 , 2
6 과 14 의 공약수 : 1 , 2
</pre>
</li></ol>

<blockquote>
<pre>
<div style="border:1 solid;width:700;padding:10px">
30 = 5 + 25 ... 30 과 5 의 공약수 = 5 와 25 의 공약수
9 = 3 + 6 ... 9 와 3 의 공약수 = 3 과 6 의 공약수 
30 = 10 +20 ... 30 과 10 의 공약수 = 10 과 20 의 공약수 
..........
a = b + c
a,b 의 공약수와 b,c 의 공약수는 같다. 
즉 세 수 a,b,c 의 공약수는 같다 이 것이 문제의 핵심이다.

<p><img src="./유클리드 호제법_files/because.gif"><b> a , b 의 공약수 k 로 양 변을 나누면 좌편은 0 , 우변 중 b 는  0 이다.
c 도 k 로 나누어져야 등식을 만족한다.</b>
</p></div>

30 과 8 의 최대 공약수를 구하는 과정을 보면 , 
<ul>
<li>30 = 8 + 22
<br>30 , 8 , 22 의 공약수는 같다.
</li><li>30 = 8 + 8 + 14  , 8 을 하나 더 분리하더라도 마찬가지 
</li><li>30 = 8 + 8 + 8 + 6
<br>
30 = 8*3 + 6
(30 과  8 공약수)  =( 8 과  6 은 공약수)
같은 공약수를 가지니 최대 공약수도 같다.

</li></ul>
</pre>
</blockquote>

<!--
<h3>(2) 수학적으로 증명하기 </h3>
// 작업 중

<h4> 대우 명제 </h4>

<h4> 귀류법 </h4>

<blockquote>
간접 증명인 귀류법을 이용한다. 

<p>귀류법은 ...예를 들어,   세상에는 두 분류의 사람 착한 사람 ,나쁜 사람이 있다고 하는 경우 
철수가 나쁜 사람이 아니다 라고 하면 철수는 착한 사람이 된다.

<p>철수가 좋은 사람라는 것을 증명하기 위해 간접적으로 철수가 나쁜 사람이 아니다 라고
증명하는 방법이 증명 방법 중에 하나인 귀류법 이다.

<p>그러면 바로 증명하지 않고 왜 둘러서 증명하느냐 하면 둘러서 증명하는 것이 쉽기 때문~~~~~

<p>proof)
<pre>
A , B 의 최대공약수를 G 라고 하면 

<p><img src="./img/euclid.gif">
.... a,b 는 서로 소

<p><img src="./img/euclid1.gif">

A,B 를 대입하면 

<p><img src="./img/euclid2.gif">

r 에 대해서 정리하면 

<p><img src="./img/euclid3.gif">

<p><img src="./img/euclid4.gif">

보이고자 하는 것은 ..... B 와 r 의 최대공약수가 G 라는 것을 보이면 된다.

일단, G 는 B , r 의 공약수라는 것은 식에서 나타난다.

b , a - bq 가 서로 소라는 것만을 증명하면 되는데 .... 이 부분에서 귀류법을 이용한다.  

b 와 a-bq 가 서로소가 아니라고 하자.( 이 것이 틀린 것이라면 두 수는 서로 소이다.)

b = m * k ---1
a-bq = m * k' ---2

1 이 아닌 m 이 존재한다.

1 식에 2 식을 대입하면 ,

a - m*k*q = m *k'

a 에 대해서 정리하면  a = m*k*q + mk' = m(k*q + k')

a,b 가 서로 소라는 가정에 모순되어서 

b , a-bq 는 서로 소이다.
</pre>

</blockquote>
-->

<h3>(2) 구현 </h3>

<blockquote>
32 와 20 의 최대 공약수를 구하여 보자.

<ul>
<li> 32 mod 20  = 12 ... gcd(32,20) = gcd(20,12)  
</li><li> 20 mod 12  =  8 ... gcd(20,12) = gcd(12,8)   
</li><li> 12 mod 8  = 4 ... gcd(12,8) = gcd(8,4)       
</li><li> 8 mod 4 = 0  ...  gcd(8,4) = 4               
</li></ul>

<hr width="300" align="left">
<ul>
<li>m: 32 n:20
</li><li>m: 20 n:12
</li><li>m: 12 n:8
</li><li>m: 8  n:4 
</li><li>m: 4  n:0 
</li></ul>

소스:
<div><div id="highlighter_973609" class="syntaxhighlighter  c"><div class="toolbar"><span><a href="http://211.228.163.31/30stair/eu/eu.php?pname=eu#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="c plain">m = 32;</code></div><div class="line number2 index1 alt1"><code class="c plain">n = 20;</code></div><div class="line number3 index2 alt2"><code class="c keyword bold">for</code><code class="c plain">(;;){</code></div><div class="line number4 index3 alt1"><code class="c spaces">&nbsp;&nbsp;&nbsp;</code><code class="c plain">t = m;</code></div><div class="line number5 index4 alt2"><code class="c spaces">&nbsp;&nbsp;&nbsp;</code><code class="c plain">m = n;</code></div><div class="line number6 index5 alt1"><code class="c spaces">&nbsp;&nbsp;&nbsp;</code><code class="c plain">n = t % n;</code></div><div class="line number7 index6 alt2"><code class="c spaces">&nbsp;&nbsp;&nbsp;</code><code class="c keyword bold">if</code> <code class="c plain">( n == 0 ) {</code></div><div class="line number8 index7 alt1"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="c comments">// m 이 최대 공약수 </code></div><div class="line number9 index8 alt2"><code class="c spaces">&nbsp;&nbsp;&nbsp;</code><code class="c plain">}</code></div><div class="line number10 index9 alt1"><code class="c plain">}</code></div></div></td></tr></tbody></table></div></div>

m &lt; n 인 경우 한 번 루프를 돌면 m &gt; n 상태로 바뀌므로 m 과 n 의 크기에 관계없이
최대 공약수를 구할 수 있다.

</blockquote>

<h3>2. 최소 공배수(LCM) 구하기</h3>

<blockquote>
두 수 A,B 의 최대공약수를 G 라하면 

<p><img src="./유클리드 호제법_files/gcd.gif">

</p><pre class="io">A = G * a
B = G * b( a,b 는 서로 소)
</pre>

두 수의 곱은 A * B = G*L 이다.( L :최소 공배수)

<blockquote>
<img src="./유클리드 호제법_files/because.gif"> A*B = G*a*G*b = G * G*a*b = G * L 
</blockquote>

두 수와 최대공약수를 알 때 최소 공배수는 L = A*B/G 로 구할 수 있다.

<p>구현시 A*B 를 먼저하면 자리 넘침이 발생할 수 있으므로 L = A/G*B 
</p></blockquote>

<h3>3. 확장 유클리드 알고리즘</h3>
<blockquote>

</blockquote>

<pre class="src">출처: dovelet
</pre>
      
<hr>
<a href="http://211.228.163.31/judgeonline/showmessage.php?pname=eu">[질/답]</a>
<div align="right">
<a href="http://211.228.163.31/index.php">[홈으로]</a>&nbsp;&nbsp;<a href="javascript:history.go(-1)">[뒤 로]</a>
</div>

   

</body></html>